<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>意識の構造 - Consciousness Structure</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@300;400&display=swap" rel="stylesheet">
  
  <!-- Bootstrap 5.3.3 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <style>
    :root {
      /* === kesson-space color tokens === */
      --color-accent: 100, 150, 255;
      --color-sub-text: 180, 200, 230;
      --color-highlight: 220, 230, 245;
      --color-heading: 255, 255, 255;
      --color-bg-body: #050508;

      /* === Typography tokens === */
      --kesson-font-serif-display: "Noto Serif JP", "Yu Mincho", "MS PMincho", serif;
      --kesson-font-serif-ui: 'Georgia', "Noto Serif JP", serif;
      --kesson-font-mono-ui: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      --kesson-letter-ui-wide: 0.1em;
      --kesson-letter-ui-heading: 0.15em;

      /* === Component tokens === */
      --kesson-glass-bg: rgba(20, 25, 40, 0.9);
      --kesson-glass-border: rgba(var(--color-accent), 0.1);
      --kesson-action-bg: rgba(var(--color-accent), 0.1);
      --kesson-action-border: rgba(var(--color-accent), 0.2);
      --kesson-action-text: rgba(var(--color-sub-text), 0.5);
      --kesson-action-bg-hover: rgba(var(--color-accent), 0.2);
      --kesson-action-text-hover: rgba(var(--color-highlight), 0.7);
    }

    body {
      background-color: var(--color-bg-body);
      color: rgba(var(--color-highlight), 0.85);
      font-family: var(--kesson-font-serif-display);
      margin: 0;
      overflow-x: hidden;
      line-height: 1.85;
    }

    /* Background Canvas */
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      z-index: 0;
    }

    /* Interactive layer behind content, captures OrbitControls */
    #interaction-layer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      z-index: 1;
      cursor: grab;
    }
    #interaction-layer:active {
      cursor: grabbing;
    }

    /* Hero Section */
    .hero-section {
      position: relative;
      z-index: 2;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background: transparent;
      pointer-events: none; /* Let drag events through to interaction-layer */
    }

    /* Layout Components */
    .main-content {
      position: relative;
      z-index: 10;
      padding-bottom: 120px;
      pointer-events: none; /* Let drag events through to interaction-layer outside of cards */
    }

    .glass-card {
      pointer-events: auto; /* Re-enable for the card content */
      background: rgba(20, 25, 40, 0.9);
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      border: 1px solid rgba(100, 150, 255, 0.1);
      border-radius: 3px;
      padding: 3.5rem;
      box-shadow: 0 4px 12px rgba(100, 150, 255, 0.15);
      margin-bottom: 4rem;
    }

    .section-accent-title {
      font-size: 0.75rem;
      font-family: var(--kesson-font-mono-ui);
      color: rgba(var(--color-sub-text), 0.6);
      letter-spacing: var(--kesson-letter-ui-heading);
      border-left: 2px solid rgba(var(--color-accent), 0.5);
      padding-left: 1.2rem;
      margin-bottom: 2.5rem;
    }

    .concept-body {
      font-size: 0.92rem;
      color: rgba(var(--color-highlight), 0.85);
    }

    .concept-body p {
      margin-bottom: 1.5rem;
    }

    .commentary-box {
      position: relative;
      background: rgba(var(--color-accent), 0.03);
      border-left: 1px solid rgba(var(--color-accent), 0.2);
      padding: 1.5rem 2rem;
      margin-top: 3rem;
    }

    .commentary-title {
      font-family: var(--kesson-font-mono-ui);
      font-size: 0.65rem;
      letter-spacing: 0.15em;
      color: rgba(var(--color-accent), 0.6);
      text-transform: uppercase;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
    }

    .commentary-title::before {
      content: '';
      display: inline-block;
      width: 12px;
      height: 1px;
      background: rgba(var(--color-accent), 0.4);
      margin-right: 10px;
    }

    .commentary-text {
      font-size: 0.88rem;
      color: rgba(var(--color-highlight), 0.75);
      font-style: italic;
      line-height: 1.8;
    }

    /* Meta Info Styles */
    .meta-label {
      font-family: var(--kesson-font-mono-ui);
      font-size: 0.7rem;
      color: rgba(var(--color-accent), 0.6);
      text-transform: uppercase;
      margin-bottom: 0.4rem;
      display: block;
    }

    .meta-value {
      font-size: 0.88rem;
      color: rgba(var(--color-highlight), 0.9);
      margin-bottom: 2rem;
    }

    .prompt-container {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(var(--color-accent), 0.12);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 2rem;
    }

    .prompt-ref-image-wrap {
      position: relative;
      background: rgba(255, 255, 255, 0.02);
      border-bottom: 1px solid rgba(var(--color-accent), 0.08);
      padding: 1.5rem;
      text-align: center;
    }

    .prompt-ref-image {
      max-width: 100%;
      height: auto;
      border: 1px solid rgba(var(--color-accent), 0.05);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
    }

    .prompt-text-wrap {
      padding: 1.5rem;
    }

    .prompt-instruction-label {
      font-family: var(--kesson-font-mono-ui);
      font-size: 0.6rem;
      color: rgba(var(--color-accent), 0.4);
      letter-spacing: 0.1em;
      margin-bottom: 0.8rem;
      display: block;
    }

    .prompt-text {
      font-family: var(--kesson-font-mono-ui);
      font-size: 0.82rem;
      color: rgba(var(--color-highlight), 0.7);
      line-height: 1.7;
      margin: 0;
      white-space: pre-wrap;
    }

    /* Buttons / Links */
    .btn-kesson {
      background: var(--kesson-action-bg);
      border: 1px solid var(--kesson-action-border);
      color: var(--kesson-action-text);
      font-family: var(--kesson-font-serif-ui);
      padding: 10px 24px;
      text-decoration: none;
      letter-spacing: var(--kesson-letter-ui-wide);
      font-size: 0.7rem;
      transition: all 0.3s ease;
      display: inline-block;
      border-radius: 2px;
    }

    .btn-kesson:hover {
      background: var(--kesson-action-bg-hover);
      color: var(--kesson-action-text-hover);
      transform: translateY(-1px);
    }

    #scroll-hint {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
      text-align: center;
      pointer-events: none;
      transition: opacity 0.6s ease, visibility 0.6s ease;
    }

    #scroll-hint span {
      display: block;
      font-size: 0.65rem;
      color: rgba(var(--color-sub-text), 0.3);
      font-family: var(--kesson-font-serif-ui);
      letter-spacing: 0.1em;
      margin-bottom: 4px;
    }

    #scroll-hint .arrow {
      font-size: 1.2rem;
      color: rgba(var(--color-sub-text), 0.25);
      animation: kesson-pulse 3s ease-in-out infinite;
    }

    @keyframes kesson-pulse {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(4px); }
    }

    @media (max-width: 768px) {
      .glass-card {
        padding: 2.5rem 1.5rem;
      }
    }
  </style>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>

  <!-- 3D Canvas -->
  <div id="canvas-container"></div>
  
  <!-- Overlay layer to capture mouse drags for OrbitControls -->
  <div id="interaction-layer"></div>

  <!-- Hero -->
  <header class="hero-section container-fluid">
    <div id="scroll-hint">
      <span>scroll</span>
      <div class="arrow">▾</div>
    </div>
  </header>

  <!-- Content Area -->
  <main class="main-content container">
    <div class="row justify-content-center">
      <div class="col-lg-10 col-xl-8">
        
        <!-- Section: Concept & Interpretation -->
        <article class="glass-card">
          <header>
            <h2 class="section-accent-title text-uppercase">CONCEPT & INTERPRETATION</h2>
          </header>
          
          <div class="concept-body">
            <span class="meta-label" style="opacity: 0.5; margin-bottom: 1rem;">Generated by LLM:</span>
            <p>「意識」という不可視の現象を、重なり合う層（Layer）と、それらを貫く関係性の網目として捉える試み。</p>
            <p>このプロトタイプでは、SDF（Signed Distance Functions）によるレイマーチングを用いて、絶えず流動し、観測者の視点に応じてその輪郭を更新し続ける意識場をシミュレートしています。</p>
            <p>中心に向かって収束する光の核は、個としての「自己」を象徴し、そこから周囲に滲み出す波形は、他者や世界との境界が曖昧な「無意識」の広がりを示唆します。</p>
          </div>

          <div class="commentary-box">
            <h3 class="commentary-title">Graphic Commentary</h3>
            <div class="commentary-text">
              <p>このグラフィックは、ユーザーから提示された静止画（「意識の構造three.jpg」）を視覚的リファレンスとして読み解き、その造形美と概念をGLSLシェーダーとして再構築したものです。</p>
              <p class="mb-0">画像に描かれていたジャイロイド状の複雑な干渉パターンを、数理的なSDF（符号付き距離関数）へと変換することで、静止した一枚の絵に「時間」と「呼吸」という動的な次元を付与しました。背景の深度方向に伸びる光の糸は、画像が持つ奥行きを3D空間のパースペクティブとして再解釈した結果です。</p>
            </div>
          </div>
        </article>

        <!-- Section: Process & Environment -->
        <article class="glass-card">
          <header>
            <h2 class="section-accent-title text-uppercase">PROCESS & ENVIRONMENT</h2>
          </header>
          
          <div class="row">
            <div class="col-md-6">
              <span class="meta-label">LLM / Agent</span>
              <p class="meta-value">Gemini 2.5 Pro / Gemini CLI</p>
            </div>
            <div class="col-md-6">
              <span class="meta-label">Environment</span>
              <p class="meta-value">Vanilla JS + Three.js + GLSL</p>
            </div>
          </div>

          <span class="meta-label">Prompt (Image-Attached Instruction)</span>
          <div class="prompt-container">
            <div class="prompt-ref-image-wrap">
              <img src="../assets/images/consciousness-structure-static.jpg" 
                   alt="INPUT REFERENCE" 
                   class="prompt-ref-image"
                   style="max-width: 320px;">
              <div class="image-caption" style="font-size: 0.55rem; margin-top: 1rem; opacity: 0.3;">REFERENCE INPUT: 意識の構造three.jpg</div>
            </div>
            <div class="prompt-text-wrap">
              <span class="prompt-instruction-label">USER INSTRUCTION:</span>
              <p class="prompt-text">「画像を参考に、threejsによるグラフィックを生成して」</p>
            </div>
          </div>

          <footer class="mt-5 pt-4 border-top border-secondary border-opacity-10 text-center text-lg-start">
            <!-- Return link removed as per user request -->
          </footer>
        </article>

      </div>
    </div>
  </main>

  <!-- Three.js Implementation -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.0);
      }
    `;

    const fragmentShader = `
      precision highp float;
      varying vec2 vUv;
      uniform float uTime;
      uniform vec2 uResolution;
      uniform float uBreath;
      uniform vec3 uCameraPos;
      uniform vec3 uCameraDir;

      mat2 rot2(float a) {
        float s = sin(a); float c = cos(a);
        return mat2(c, -s, s, c);
      }

      float gyroid(vec3 p) {
        return dot(sin(p), cos(p.yzx));
      }

      float getDensity(vec3 p) {
        vec3 q = p;
        q.xy *= rot2(p.z * 0.15 + uTime * 0.1);
        q.x -= uTime * 0.2;
        
        float g = gyroid(q * 2.5);
        float membrane = 1.0 - smoothstep(0.0, 0.15 * (1.0 + uBreath * 0.5), abs(g));
        
        float radial = length(q.yz);
        float shell = exp(-2.5 * radial * radial);
        
        return membrane * 0.7 + shell * 0.3;
      }

      void main() {
        vec2 uv = (vUv * 2.0 - 1.0);
        float aspect = uResolution.x / uResolution.y;
        uv.x *= aspect;
        
        vec3 ro = uCameraPos;
        
        // Calculate dynamic view direction based on uCameraDir
        vec3 forward = normalize(uCameraDir);
        vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));
        vec3 up = cross(right, forward);
        vec3 rd = normalize(forward * 1.5 + right * uv.x + up * uv.y);

        vec3 col = vec3(0.0);
        float t = 0.0;
        float transmittance = 1.0;

        for(int i = 0; i < 64; i++) {
          vec3 p = ro + rd * t;
          float radial = length(p.yz);
          float envelope = smoothstep(2.5, 0.1, radial);
          
          if (envelope > 0.01) {
            float dens = getDensity(p) * envelope;
            if (dens > 0.01) {
              vec3 tint = mix(vec3(0.1, 0.2, 0.6), vec3(0.9, 0.8, 1.0), dens);
              float stepAlpha = dens * 0.15;
              col += tint * stepAlpha * transmittance;
              transmittance *= (1.0 - stepAlpha);
            }
          }
          t += 0.15;
          if (t > 12.0 || transmittance < 0.01) break;
        }

        col = pow(col, vec3(0.8));
        gl_FragColor = vec4(col, 1.0 - transmittance);
      }
    `;

    let scene, camera, renderer, material, controls;
    let startTime = Date.now();

    function init() {
      scene = new THREE.Scene();
      
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 0, 4);
      
      const geometry = new THREE.PlaneGeometry(2, 2);
      material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          uBreath: { value: 0 },
          uCameraPos: { value: new THREE.Vector3() },
          uCameraDir: { value: new THREE.Vector3() }
        },
        vertexShader,
        fragmentShader,
        transparent: true
      });

      const mesh = new THREE.Mesh(geometry, material);
      camera.add(mesh);
      mesh.position.z = -1;
      scene.add(camera);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // Attach OrbitControls to interaction-layer instead of renderer.domElement
      const interactEl = document.getElementById('interaction-layer');
      controls = new OrbitControls(camera, interactEl);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = false;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      window.addEventListener('resize', onWindowResize);

      // Scroll hint visibility logic
      const scrollHint = document.getElementById('scroll-hint');
      window.addEventListener('scroll', () => {
        if (window.scrollY > 50) {
          scrollHint.style.opacity = '0';
          scrollHint.style.visibility = 'hidden';
        } else {
          scrollHint.style.opacity = '1';
          scrollHint.style.visibility = 'visible';
        }
      }, { passive: true });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      controls.update();
      
      const elapsed = (Date.now() - startTime) / 1000;
      material.uniforms.uTime.value = elapsed;
      material.uniforms.uBreath.value = Math.sin(elapsed * 0.5) * 0.5 + 0.5;
      
      material.uniforms.uCameraPos.value.copy(camera.position);
      const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      material.uniforms.uCameraDir.value.copy(dir);
      
      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
